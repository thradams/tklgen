
[TKLGEN HOME](tklgen.md)

##Tutorial and sample

This sample parse expressions.

This **is not the tklgen grammar** but it helps to think how to build LL1 grammars.


The brackets [ and ] enclose an optional part of the production. 
The braces { and } enclose parts of the productions that may be repeated 0 or more times, and | separates alternatives. 
The unquoted parentheses ( and ) serve only to group elements in a production.)

```
  E --> T {( "+" | "-" ) T}
  T --> F {( "*" | "/" ) F}
  F --> P ["^" F]
  P --> v | "(" E ")" | "-" T
```


Now lets see how to build a tklgen LL1 grammar:

###grammar.txt

```cpp

module Sample2
{
  language Sample2
   {
    token Plus = '+';
    token Minus = '-';
    token Multi = '*';
    token Div = '/';
    token Power = '^';
    token Open = '(';
    token Close = ')';
    token End = ';';
    token EndMark = '\0';
    token Integer   = ('0'..'9')+;
    token Identifier   = ('a'..'z' | 'A'..'Z' | '_' | '$') +
                       ('0'..'9' + ('a'..'z' | 'A'..'Z' | '_' | '$') +) ?;
    
    interleave Blanks  = (" " | "\n" | "\t" | "\r") +;

    
    syntax Main = Expressions;
    syntax Expression = E ';' {PrintNewLine};
    syntax Expressions = Expression Expressions | empty;

    // E --> T {( "+" | "-" ) T}
    syntax E = T E2;
    syntax E2 = '+' T {PrintPlus} E2 |
                '-' T {PrintMinus} E2 |
                empty;

    // T --> F {( "*" | "/" ) F}
    syntax T = F T2;
    syntax T2 = '*' F {PrintMulti} T2|
                '/' F {PrintDiv}T2|
                empty;

    // F --> P ["^" F]
    syntax F = P FOpt;
    syntax FOpt = '^' F {PrintPower} | empty;

    // P --> v | "(" E ")" | "-" T
    syntax P = {PrintLexeme} Integer |
               {PrintLexeme} Identifier | 
               '(' E ')' | 
               '-' T {PrintNeg};
      }
}

```

Use this command line:

```
 tklgen grammar.txt
```

The files below will be generated:

```
 Sample2Parser.h
 Sample2Parser.cpp
 Sample2DFA.h
```


The files below do not depends on grammar. They are generated for convenience. Use the option -s to ignore this generation next time.

```
Tokenizer.h
FileStream.h
StringStream.h
SampleProgram.txt
```


###Sample2Parser.h

```cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cassert>
#include <string>
#include "tokenizer.h"
#include "Sample2DFA.h"


#include "FileStream.h"

namespace Sample2
{
    enum ErrorCode
    {
        ErrorCodeUnexpectedEof,
        ErrorCodeUnexpectedToken
    };

    class Context;
    void OnError(Context&, ErrorCode);

    class ParserException : public std::exception
    {
    public:
        int m_Line;
        int m_Col;
        ErrorCode m_Error;
        ParserException(int line, int col, ErrorCode error)
            : m_Line(line), m_Col(col), m_Error(error)
        {
        }
    };


    class Context
    {
    public:
        FileStream& m_Stream;

        Tokens m_CurrentToken;
        std::wstring m_lexeme;
        
        Context(FileStream& stream) : m_Stream(stream)
        {
            if (!NextToken<DFA>(
                        stream,
                        m_lexeme,
                        m_CurrentToken))
            {
              assert(false);
            }
        }
    };

    inline void OnError(Context& context, ErrorCode er)
    {
        throw ParserException(GetLine(context.m_Stream),
                              GetCol(context.m_Stream),
                              er);
    }

    inline Tokens GetToken(Context& context)
    {
        return context.m_CurrentToken;
    }

    inline bool Match(Context& context, Tokens tk)
    {
        if (tk != context.m_CurrentToken)
        {
            OnError(context, ErrorCodeUnexpectedToken);
            return false;
        }

        if (!NextToken<DFA>(
                    context.m_Stream,
                    context.m_lexeme,
                    context.m_CurrentToken))
        {
        }
        return true;
    }


    inline void Action_PrintNewLine(Context& /*ctx*/)
    {
    }

    inline void Action_PrintPlus(Context& /*ctx*/)
    {
    }

    inline void Action_PrintMinus(Context& /*ctx*/)
    {
    }

    inline void Action_PrintMulti(Context& /*ctx*/)
    {
    }

    inline void Action_PrintDiv(Context& /*ctx*/)
    {
    }

    inline void Action_PrintPower(Context& /*ctx*/)
    {
    }

    inline void Action_PrintLexeme(Context& /*ctx*/)
    {
    }

    inline void Action_PrintNeg(Context& /*ctx*/)
    {
    }

    void Parse_Main(Context&);
} // namespace

```



###Sample2Parser.cpp

```cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <cassert>
#include <string>
#include "tokenizer.h"
#include "Sample2DFA.h"
#include "Sample2Parser.h"


namespace Sample2
{
    //forward declarations 
    void Parse_Main(Context&);
    void Parse_Expressions(Context&);
    void Parse_E(Context&);
    void Parse_T(Context&);
    void Parse_E2(Context&);
    void Parse_Expression(Context&);
    void Parse_T2(Context&);
    void Parse_F(Context&);
    void Parse_P(Context&);
    void Parse_FOpt(Context&);


    void Parse_Main(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKEndMark ||
            token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //Main => Expressions 
            Parse_Expressions(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_Expressions(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //Expressions => Expression Expressions 
            Parse_Expression(ctx);
            Parse_Expressions(ctx);
        }
        else if (token == TKEndMark)
        {
            //Expressions => Epsilon 
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_E(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //E => T E2 
            Parse_T(ctx);
            Parse_E2(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_T(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //T => F T2 
            Parse_F(ctx);
            Parse_T2(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_E2(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKPlus)
        {
            //E2 => Plus T E2 
            Match(ctx, TKPlus);
            Parse_T(ctx);
            Action_PrintPlus(ctx);
            Parse_E2(ctx);
        }
        else if (token == TKMinus)
        {
            //E2 => Minus T E2 
            Match(ctx, TKMinus);
            Parse_T(ctx);
            Action_PrintMinus(ctx);
            Parse_E2(ctx);
        }
        else if (token == TKClose ||
            token == TKEnd)
        {
            //E2 => Epsilon 
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_Expression(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //Expression => E End 
            Parse_E(ctx);
            Match(ctx, TKEnd);
            Action_PrintNewLine(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_T2(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMulti)
        {
            //T2 => Multi F T2 
            Match(ctx, TKMulti);
            Parse_F(ctx);
            Action_PrintMulti(ctx);
            Parse_T2(ctx);
        }
        else if (token == TKDiv)
        {
            //T2 => Div F T2 
            Match(ctx, TKDiv);
            Parse_F(ctx);
            Action_PrintDiv(ctx);
            Parse_T2(ctx);
        }
        else if (token == TKPlus ||
            token == TKMulti ||
            token == TKMinus ||
            token == TKDiv ||
            token == TKPower ||
            token == TKClose ||
            token == TKEnd)
        {
            //T2 => Epsilon 
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_F(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKMinus ||
            token == TKIdentifier ||
            token == TKOpen ||
            token == TKInteger)
        {
            //F => P FOpt 
            Parse_P(ctx);
            Parse_FOpt(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_P(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKInteger)
        {
            //P => Integer 
            Action_PrintLexeme(ctx);
            Match(ctx, TKInteger);
        }
        else if (token == TKIdentifier)
        {
            //P => Identifier 
            Action_PrintLexeme(ctx);
            Match(ctx, TKIdentifier);
        }
        else if (token == TKOpen)
        {
            //P => Open E Close 
            Match(ctx, TKOpen);
            Parse_E(ctx);
            Match(ctx, TKClose);
        }
        else if (token == TKMinus)
        {
            //P => Minus T 
            Match(ctx, TKMinus);
            Parse_T(ctx);
            Action_PrintNeg(ctx);
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

    void Parse_FOpt(Context& ctx)
    {
        auto token = GetToken(ctx);

        if (token == TKPower)
        {
            //FOpt => Power F 
            Match(ctx, TKPower);
            Parse_F(ctx);
            Action_PrintPower(ctx);
        }
        else if (token == TKPlus ||
            token == TKMulti ||
            token == TKMinus ||
            token == TKDiv ||
            token == TKPower ||
            token == TKClose ||
            token == TKEnd)
        {
            //FOpt => Epsilon 
        }
        else
        {
            OnError(ctx, ErrorCodeUnexpectedToken);
        }
    }

} //namespace Sample2

}}}

###Sample2DFA.h

```cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#ifndef __SAMPLE2DFA_H__
#define __SAMPLE2DFA_H__

namespace Sample2
{

enum Tokens
{
    TKPlus,
    TKMinus,
    TKMulti,
    TKDiv,
    TKPower,
    TKOpen,
    TKClose,
    TKEnd,
    TKEndMark,
    TKInteger,
    TKIdentifier,
    TKBlanks,
};

inline const wchar_t* TokensToString(Tokens e)
{
    switch(e)
    {
    case TKPlus: return L"Plus";
    case TKMinus: return L"Minus";
    case TKMulti: return L"Multi";
    case TKDiv: return L"Div";
    case TKPower: return L"Power";
    case TKOpen: return L"Open";
    case TKClose: return L"Close";
    case TKEnd: return L"End";
    case TKEndMark: return L"EndMark";
    case TKInteger: return L"Integer";
    case TKIdentifier: return L"Identifier";
    case TKBlanks: return L"Blanks";
    default:break;
    }
    return L"";
}

struct DFA
{
    typedef Tokens TokenType;

    static int GetNext(int state, wchar_t ch)
    {
        switch (state)
        {
            case 0:
            if (ch == L'\0')
                return 1;
        else if (ch >= L'\t' && ch <= L'\n')
          return 2;
            else if (ch == L'\r')
                return 2;
            else if (ch == L' ')
                return 2;
            else if (ch == L'$')
                return 3;
            else if (ch == L'(')
                return 4;
            else if (ch == L')')
                return 5;
            else if (ch == L'*')
                return 6;
            else if (ch == L'+')
                return 7;
            else if (ch == L'-')
                return 8;
            else if (ch == L'/')
                return 9;
        else if (ch >= L'0' && ch <= L'9')
          return 10;
            else if (ch == L';')
                return 11;
        else if (ch >= L'A' && ch <= L'Z')
          return 3;
            else if (ch == L'^')
                return 12;
            else if (ch == L'_')
                return 3;
        else if (ch >= L'a' && ch <= L'z')
           return 3;
    break; // 
            case 1:
        //TKEndMark
    break; // 
            case 2:
        if (ch >= L'\t' && ch <= L'\n')
          return 2;
            else if (ch == L'\r')
                return 2;
            else if (ch == L' ')
                return 2;
        //TKBlanks
    break; // 
            case 3:
            if (ch == L'$')
                return 3;
        else if (ch >= L'0' && ch <= L'9')
          return 14;
        else if (ch >= L'A' && ch <= L'Z')
          return 3;
            else if (ch == L'_')
                return 3;
        else if (ch >= L'a' && ch <= L'z')
          return 3;
        //TKIdentifier
    break; // 
            case 4:
        //TKOpen
    break; // 
            case 5:
        //TKClose
    break; // 
            case 6:
        //TKMulti
    break; // 
            case 7:
        //TKPlus
    break; // 
            case 8:
        //TKMinus
    break; // 
            case 9:
        //TKDiv
    break; // 
            case 10:
        if (ch >= L'0' && ch <= L'9')
          return 10;
        //TKInteger
    break; // 
            case 11:
        //TKEnd
    break; // 
            case 12:
        //TKPower
    break; // 
            case 13:
  return -1;
    break; // 
            case 14:
            if (ch == L'$')
                return 15;
        else if (ch >= L'0' && ch <= L'9')
          return 14;
        else if (ch >= L'A' && ch <= L'Z')
          return 15;
            else if (ch == L'_')
                return 15;
        else if (ch >= L'a' && ch <= L'z')
           return 15;
    break; // 
            case 15:
            if (ch == L'$')
                return 15;
        else if (ch >= L'A' && ch <= L'Z')
          return 15;
            else if (ch == L'_')
                return 15;
        else if (ch >= L'a' && ch <= L'z')
          return 15;
        //TKIdentifier
    break; // 
        } //switch
        return -1;
    }

    static bool IsInterleave(Tokens tk)
    {
        return tk == TKBlanks;
    }

    static bool GetTokenFromState(int state, Tokens& tk)
    {
        switch(state)
        {
            case 1: tk = TKEndMark; break;
            case 2: tk = TKBlanks; break;
            case 3: tk = TKIdentifier; break;
            case 4: tk = TKOpen; break;
            case 5: tk = TKClose; break;
            case 6: tk = TKMulti; break;
            case 7: tk = TKPlus; break;
            case 8: tk = TKMinus; break;
            case 9: tk = TKDiv; break;
            case 10: tk = TKInteger; break;
            case 11: tk = TKEnd; break;
            case 12: tk = TKPower; break;
            case 15: tk = TKIdentifier; break;
            default:
                return false;
        }
        return true;
    }
};
} //namespace
#endif //header

```



###Tokenizer (do not depend on grammar)

```cpp
//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

inline void Clear(std::wstring& ws)
{
    ws.clear();
}

inline void Append(std::wstring& ws, wchar_t ch)
{
    ws.append(1, ch);
}


inline void Clear(std::string& ws)
{
    ws.clear();
}

inline void Append(std::string& ws, char ch)
{
    ws.append(1, ch);
}

template < class TDFA,
         class T,
         class TInputStream >
bool NextTokenNoInterleave(TInputStream& stream,
                           T& lexeme,
                           typename TDFA::TokenType& tk)
{
    Clear(lexeme);
    int lastGoodState = -1;
    int currentState = 0;
    wchar_t ch;

    while (GetChar(stream, ch))
    {
        currentState = TDFA::GetNext(currentState, ch);

        if (currentState == -1)
        {
            PutBack(stream, ch);
            break;
        }

        typename TDFA::TokenType tk2;

        if (TDFA::GetTokenFromState(currentState, tk2))
        {
            tk = tk2;
            lastGoodState = currentState;
        }

        Append(lexeme, ch);
    }

    return (lastGoodState != -1);
}

template < class TDFA,
         class T,
         class TInputStream >
bool NextToken(TInputStream& stream,
               T& lexeme,
               typename TDFA::TokenType& tk)
{
    for (;;)
    {
        if (!NextTokenNoInterleave<TDFA>(stream, lexeme, tk))
        {
            return false;
        }

        if (!TDFA::IsInterleave(tk))
        {
            return true;
        }
    }
}



```

###FileStream (do not depend on grammar)

```cpp


#pragma once

#include <cstdio>
#include <cassert>

struct FileStream
{
  typedef const wchar_t* BufferIterator;

  wchar_t*     m_pCharacteres;
  const size_t m_MaxBufferSize;
  wchar_t*     m_pCurrentChar;
  FILE*        m_hFile;
  size_t       m_CurrentLine;
  size_t       m_CurrentCol;

  bool         m_HasPutBack;
  wchar_t      m_PutBackCharacter;

  bool         m_EofSent;

  BufferIterator FirstBufferEnd() const
  {
    return m_pCharacteres + m_MaxBufferSize - 1;
  }

  BufferIterator SecondBufferEnd() const
  {
    return m_pCharacteres + m_MaxBufferSize * 2 - 1;
  }

  bool GetCharCore(wchar_t& ch)
  {
    if (m_HasPutBack)
    {
      ch = m_PutBackCharacter;
      m_HasPutBack = false;
      m_PutBackCharacter = 0;
      return true;
    }

    if (m_EofSent)
      return false;

    ch = *m_pCurrentChar++;

    if (ch == L'\0')
    {
      ch = '\0';
      m_EofSent = true;
    }
    else
    {
      if (*m_pCurrentChar == L'\0')
      {
        if (m_pCurrentChar == FirstBufferEnd())
        {
          wchar_t* pSecondBuffer =
            m_pCharacteres + m_MaxBufferSize;

          size_t r = fread(pSecondBuffer,
                           sizeof(wchar_t),
                           m_MaxBufferSize - 1,
                           m_hFile);
          pSecondBuffer[r] = 0;
          m_pCurrentChar = pSecondBuffer;
        }
        else if (m_pCurrentChar == SecondBufferEnd())
        {
          wchar_t* pFirstBuffer = m_pCharacteres;

          size_t r = fread(pFirstBuffer,
                           sizeof(wchar_t),
                           m_MaxBufferSize - 1,
                           m_hFile);

          pFirstBuffer[r] = 0;
          m_pCurrentChar = pFirstBuffer;
        }
      }
    }

    assert(m_pCharacteres[m_MaxBufferSize - 1] == 0);
    assert(m_pCharacteres[m_MaxBufferSize * 2 - 1] == 0);
    return true;
  }

public:

  FileStream(const wchar_t* fileName, size_t bufferSize = 4096)
    : m_MaxBufferSize(bufferSize)
    , m_CurrentLine(1)
    , m_CurrentCol(1)
    , m_HasPutBack(false)
    , m_PutBackCharacter(L'\0')
    , m_EofSent(false)
  {
    assert(bufferSize >= 2);

    //allocate 2 buffers
    m_pCharacteres = new wchar_t[m_MaxBufferSize * 2];
    m_pCharacteres[m_MaxBufferSize * 2 - 1] = 0;
    m_pCharacteres[m_MaxBufferSize - 1] = 0;
    m_pCurrentChar = m_pCharacteres;

    errno_t err = _wfopen_s(&m_hFile, fileName, L"r,ccs=UTF-8");

    if (err == 0)
    {
      size_t r = fread(m_pCharacteres,
                       sizeof(wchar_t),
                       m_MaxBufferSize - 1,
                       m_hFile);

      m_pCharacteres[r] = L'\0';
    }
  }

  ~FileStream()
  {
    fclose(m_hFile);
    delete [] m_pCharacteres;
  }

  friend void PutBack(FileStream& fileStream, wchar_t ch)
  {
    assert(fileStream.m_HasPutBack == false);

    if (ch == L'\n')
    {
      if (fileStream.m_CurrentLine > 1)
      {
        fileStream.m_CurrentLine--;
      }
    }
    else
    {
      if (fileStream.m_CurrentCol > 1)
      {
        fileStream.m_CurrentCol--;
      }
    }

    fileStream.m_PutBackCharacter = ch;
    fileStream.m_HasPutBack = true;
  }
  
  friend bool GetChar(FileStream& fileStream, wchar_t& ch)
  {
    bool b = fileStream.GetCharCore(ch);

    if (b && ch == L'\n')
    {
      fileStream.m_CurrentLine++;
      fileStream.m_CurrentCol = 1;
    }
    else
    {
      fileStream.m_CurrentCol++;
    }

    return b;
  }

  friend size_t GetLine(const FileStream& fileStream)
  {
    return fileStream.m_CurrentLine;
  }

  friend size_t GetCol(const FileStream& fileStream)
  {
    return fileStream.m_CurrentCol;
  }
};


}}}

###StringStream (do not depend on grammar) 

```cpp

#pragma once
#include <cassert>

struct StringStream
{
  const wchar_t* m_pCharacteres;
  const wchar_t* m_pCurrentChar;
  size_t         m_CurrentLine;
  size_t         m_CurrentCol;
  bool           m_HasPutBack;
  wchar_t        m_PutBackCharacter;
  bool           m_EofSent;

  bool GetCharCore(wchar_t& ch)
  {
    if (m_HasPutBack)
    {
      ch = m_PutBackCharacter;
      m_HasPutBack = false;
      m_PutBackCharacter = 0;
      return true;
    }

    if (m_EofSent)
      return false;

    ch = *m_pCurrentChar++;

    if (ch == L'\0')
    {
      ch = '\0';
      m_EofSent = true;
    }

    return true;
  }

public:

  StringStream(const wchar_t* psz)
    : m_pCharacteres(psz)
    , m_CurrentLine(1)
    , m_CurrentCol(1)
    , m_HasPutBack(false)
    , m_PutBackCharacter(L'\0')
    , m_EofSent(false)
  {
    m_pCurrentChar = m_pCharacteres;
  }

  friend void PutBack(StringStream& stream,  wchar_t ch)
  {
    assert(stream.m_HasPutBack == false);

    if (ch == L'\n')
    {
      if (stream.m_CurrentLine > 1)
      {
        stream.m_CurrentLine--;
      }
    }
    else
    {
      if (stream.m_CurrentCol > 1)
      {
        stream.m_CurrentCol--;
      }
    }

    stream.m_PutBackCharacter = ch;
    stream.m_HasPutBack = true;
  }

  friend bool GetChar(StringStream& stream, wchar_t& ch)
  {
    bool b = stream.GetCharCore(ch);

    if (b && ch == L'\n')
    {
      stream.m_CurrentLine++;
      stream.m_CurrentCol = 1;
    }
    else
    {
      stream.m_CurrentCol++;
    }

    return b;
  }

  size_t GetLine(const StringStream& stream)
  {
    return stream.m_CurrentLine;
  }

  size_t GetCol(const StringStream& stream) 
  {
    return stream.m_CurrentCol;
  }
};

```


###SampleProgram.txt (just a sample)


```cpp

#include "stdafx.h"
#include "Sample2Parser.h"
#include <iostream>

int _tmain(int argc, _TCHAR* argv[])
{
  if (argc == 1)
  {
    std::cout << "missing input file ";
    return 1;
  }

  try
  {
    FileStream ss(argv[1]);
    Sample2::Context ctx(ss);
    Sample2::Parse_Main(ctx);
  }
  catch (const Sample2::ParserException& e)
  {
    std::cout << "Error : line, col = " << e.m_Line << ", " << e.m_Col << std::endl;
  }
  catch (const std::exception& e)
  {
    std::cout << e.what() << std::endl;
  }

  return 0;
}

```


###Modifed SampleParser.h


```cpp

//iostream included
#include <iostream>
using namespace std;

...

   //Actions added

    inline void Action_PrintNewLine(Context& /*ctx*/)
    {
      wcout << std::endl;
    }

    inline void Action_PrintPlus(Context& /*ctx*/)
    {    
       wcout << L" +";
    }

    inline void Action_PrintMinus(Context& /*ctx*/)
    {
        wcout << L" -";
    }

    inline void Action_PrintMulti(Context& /*ctx*/)
    {
       wcout << L" *";
    }

    inline void Action_PrintDiv(Context& /*ctx*/)
    {
       wcout << L" /";
    }

    inline void Action_PrintPower(Context& /*ctx*/)
    {
       wcout << L" ^";
    }

    inline void Action_PrintLexeme(Context& ctx)
    {
         wcout << L" " << ctx.m_lexeme;
    }

    inline void Action_PrintNeg(Context& /*ctx*/)
    {
         wcout << L" NEG";
    }

...
} // namespace

```


