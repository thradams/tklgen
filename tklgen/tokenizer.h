//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

inline void Clear(std::wstring& ws)
{
    ws.clear();
}

inline void Append(std::wstring& ws, wchar_t ch)
{
    ws.append(1, ch);
}


inline void Clear(std::string& ws)
{
    ws.clear();
}

inline void Append(std::string& ws, char ch)
{
    ws.append(1, ch);
}

template < class TDFA,
         class T,
         class TInputStream >
bool NextTokenNoInterleave(TInputStream& stream,
                           T& lexeme,
                           typename TDFA::TokenType& tk)
{
    Clear(lexeme);
    int lastGoodState = -1;
    int currentState = 0;
    wchar_t ch;

    while (GetChar(stream, ch))
    {
        currentState = TDFA::GetNext(currentState, ch);

        if (currentState == -1)
        {
            PutBack(stream, ch);
            break;
        }

        typename TDFA::TokenType tk2;

        if (TDFA::GetTokenFromState(currentState, tk2))
        {
            tk = tk2;
            lastGoodState = currentState;
        }

        Append(lexeme, ch);
    }

    return (lastGoodState != -1);
}

template < class TDFA,
         class T,
         class TInputStream >
bool NextToken(TInputStream& stream,
               T& lexeme,
               typename TDFA::TokenType& tk)
{
    for (;;)
    {
        if (!NextTokenNoInterleave<TDFA>(stream, lexeme, tk))
        {
            return false;
        }

        if (!TDFA::IsInterleave(tk))
        {
            return true;
        }
    }
}

