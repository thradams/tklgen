#include "StdAfx.h"
#include "LLOutputCpp.h"
#include <iostream>
#include <sstream>
#include <set>
#include "Grammar.h"
#include <map>
#include "CommonOutput.h"

#define TAB_1    L"    "
#define TAB__2   L"        "
#define TAB___3  L"            "
#define TAB____4 L"                "



static std::wostream& PrintProduction(std::wostream& os,
                               const Production& production,
                               Grammar& g,
                               const std::wstring& tokenprefix,
                               const std::wstring& tabs)
{
  int i = 0;
  int actionIndexAtProduction = 0;

  int actionIndex = production.GetAction(actionIndexAtProduction);

  if (actionIndex >= 0)
  {
    os << tabs << L"Action_" << g.GetActionName(actionIndex) << L"(ctx);\n";
  }

  actionIndexAtProduction++;

  for (; i < production.GetNumOfRightSymbols(); i++)
  {
    const GrammarSymbol* pS = production.GetRightSymbol(i);

    if (pS->IsTerminal())
    {
      if (pS != g.epsilon())
      {
        os << tabs << L"Match(ctx, " <<  tokenprefix << production.GetRightSymbol(i)->GetName() << L");\n";
      }
      else
      {
        //os << L"ctx.Match(" << production.GetRightSymbol(i)->GetName() << L");\n";
      }
    }
    else
    {
      os << tabs << L"Parse_" << production.GetRightSymbol(i)->GetName() << L"(ctx);\n";
    }

    actionIndex = production.GetAction(actionIndexAtProduction);

    if (actionIndex >= 0)
    {
      os << tabs << L"Action_" << g.GetActionName(actionIndex) << L"(ctx);\n";
    }

    actionIndexAtProduction++;
  }

  actionIndex = production.GetAction(actionIndexAtProduction);

  if (actionIndex >= 0)
  {
    os << tabs << L"Action_" << g.GetActionName(actionIndex) << L"(ctx);\n";
  }

  return os;
}

/*bool IsRecursive(const Production& production)
{
    for (int i = 0; i < production.GetNumOfRightSymbols(); i++)
    {
        const GrammarSymbol* pS = production.GetRightSymbol(i);

        if (pS == production.GetLeftSymbol())
        {
            return true;
        }
    }

    return false;
}*/

static std::wostream& PrintFowardDeclarations(std::wostream& os, Grammar& g, MMap& map)
{
  os << TAB_1 << L"//forward declarations \n";
  int i = 0;
  int sub = 0;
  int currentRuleIndex = -1;

  for (auto it = map.begin(); it != map.end(); it++)
  {
    if (currentRuleIndex != it->m_pNotTerminal->GetIndex())
    {
      //mudou
      currentRuleIndex = it->m_pNotTerminal->GetIndex();
      os << TAB_1 << L"void Parse_" << it->m_pNotTerminal->GetName() << L"(Context&);\n";
      sub = 0;
    }

    sub ++;
    i++;
  }

  os << L"\n\n";
  return os;
}


static void PrintActions(std::wostream& os, Grammar& g, bool virt)
{
  os << L"    //Forward declarations for actions\n";
  const wchar_t * psz =
    L"    void Action_{ACTION}(Context& /*ctx*/);\n";
    
  for (int i = 0 ; i < g.GetNumberOfActions(); i++)
  {
    std::wstring ws(psz);
    find_replace(ws, L"{ACTION}", g.GetActionName(i));
    os << ws;
  }
}

static void PrintOutputInterface(std::wostream& os, Grammar& g)
{
  const wchar_t * psz =
    L"//////////////////////////////////////////////////////////////////////////////\n"
    L"// Generated by TKLGEN - Version {DATE}\n"
    L"// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)\n"
    L"// www.thradams.com\n"
    L"//\n"
    L"// Permission to copy, use, modify, sell and distribute this software\n"
    L"// is granted provided this copyright notice appears in all copies.\n"
    L"// This software is provided \"as is\" without express or implied\n"
    L"// warranty, and with no claim as to its suitability for any purpose.\n"
    L"//\n"
    L"//////////////////////////////////////////////////////////////////////////////\n"
    L"#pragma once\n"
    L"\n"
    L"#include <cassert>\n"
    L"#include <string>\n"
    L"#include \"tokenizer.h\"\n"
    L"#include \"{GRAMMAR}Lex.h\"\n"
    L"\n"
    L"\n"
    L"#include \"FileStream.h\"\n"
    L"\n"
    L"namespace {GRAMMAR}\n"
    L"{\n"
    L"    enum ErrorCode\n"
    L"    {\n"
    L"        ErrorCodeUnexpectedEof,\n"
    L"        ErrorCodeUnexpectedToken\n"
    L"    };\n"
    L"\n"
    L"    class Context;\n"
    L"    void OnError(Context&, ErrorCode);\n"
    L"\n"
    L"    class ParserException : public std::exception\n"
    L"    {\n"
    L"    public:\n"
    L"        int m_Line;\n"
    L"        int m_Col;\n"
    L"        ErrorCode m_Error;\n"
    L"        ParserException(int line, int col, ErrorCode error)\n"
    L"            : m_Line(line), m_Col(col), m_Error(error)\n"
    L"        {\n"
    L"        }\n"
    L"    };\n"
    L"\n"
    L"\n"
    L"    class Context\n"
    L"    {\n"
    L"    public:\n"
    L"        FileStream& m_Stream;\n"
    L"\n"
    L"        Tokens m_CurrentToken;\n"
    L"        std::wstring m_lexeme;\n"
    L"        \n"
    L"        Context(FileStream& stream) : m_Stream(stream)\n"
    L"        {\n"
    L"            if (!NextToken<DFA>(\n"
    L"                        stream,\n"
    L"                        m_lexeme,\n"
    L"                        m_CurrentToken))\n"
    L"            {\n"
    L"              assert(false);\n"
    L"            }\n"
    L"        }\n"
    L"    };\n"
    L"\n"
    L"    inline void OnError(Context& context, ErrorCode er)\n"
    L"    {\n"
    L"        throw ParserException(GetLine(context.m_Stream),\n"
    L"                              GetCol(context.m_Stream),\n"
    L"                              er);\n"
    L"    }\n"
    L"\n"
    L"    inline Tokens GetToken(Context& context)\n"
    L"    {\n"
    L"        return context.m_CurrentToken;\n"
    L"    }\n"
    L"\n"
    L"    inline bool Match(Context& context, Tokens tk)\n"
    L"    {\n"
    L"        if (tk != context.m_CurrentToken)\n"
    L"        {\n"
    L"            OnError(context, ErrorCodeUnexpectedToken);\n"
    L"            return false;\n"
    L"        }\n"
    L"\n"
    L"        if (!NextToken<DFA>(\n"
    L"                    context.m_Stream,\n"
    L"                    context.m_lexeme,\n"
    L"                    context.m_CurrentToken))\n"
    L"        {\n"
    L"        }\n"
    L"        return true;\n"
    L"    }\n"
    L"\n"
    L"{ACTIONS}\n"
    L"    void Parse_Main(Context&);\n"
    L"} // namespace\n";

  std::wstring ws(psz);
  find_replace(ws, L"{DATE}", __WDATE__);
  find_replace(ws, L"{GRAMMAR}", g.GetLanguageName());
  
  std::wostringstream ss;
  PrintActions(ss, g,  false);
  find_replace(ws, L"{ACTIONS}", ss.str());
  os << ws;
}

static int PreAnalise(MMap& map, MMap::iterator it, bool& allsame)
{
  int currentRuleIndex = it->m_pNotTerminal->GetIndex();
  int currentRule = it->m_RuleIndex;

  //Faz todos desta regra (até ela mudar)

  if (it == map.end())
  {
    return 0;
  }

  int sub = 0;
  allsame = true;

  while (it->m_pNotTerminal->GetIndex() == currentRuleIndex)
  {
    if (currentRule != it->m_RuleIndex)
    {
      allsame = false;
    }

    sub++;
    it++;

    if (it == map.end())
    {
      break;
    }
  }

  //retorna quantos tem destra regra
  return sub;
}


void GenerateDescRecHeader(std::wostream& os,
                           Grammar& g,
                           MMap& map,
                           const std::wstring& tokenPrefix)
{
  PrintOutputInterface(os, g);
}

void GenerateDescRec(std::wostream& os,
                     Grammar& g,
                     MMap& map,
                     const std::wstring& tokenPrefix,
                     const std::wstring& parserFileSuffix)
{
  if (map.empty())
  {
    return;
  }

  PrintGeneratedFileHeader(os);
  PrintGeneratedFileLicense(os);


  os << L"\n";
  os << L"#include \"stdafx.h\"\n";
  os << L"#include <cassert>\n";
  os << L"#include <string>\n";
  os << L"#include \"tokenizer.h\"\n";
  os << L"#include \"" << g.GetModuleName() << L"Lex.h\"\n";
  os << L"#include \"" << g.GetModuleName() << parserFileSuffix << L".h\"\n";
  os << L"\n";
  os << L"\n";
  os << L"namespace " << g.GetLanguageName() << L"\n";
  os << L"{\n";
  // PrintOutputInterface(os, g);
  PrintFowardDeclarations(os, g, map);
  int i = 0;
  int currentRuleIndex = -1;
  auto it = map.begin();
  int rulecount = 0;

  for (; it != map.end();)
  {
    int currentRuleIndex = it->m_pNotTerminal->GetIndex();
    //Faz todos desta regra (até ela mudar)
    os << TAB_1 <<  L"void " << "Parse_" << it->m_pNotTerminal->GetName() << L"(Context& ctx)\n";
    os << TAB_1 << L"{\n";

    os << TAB__2 << L"auto token = GetToken(ctx);\n";
    os << L"\n";

    int sub = 0;
    rulecount = 0;

    while (it->m_pNotTerminal->GetIndex() == currentRuleIndex)
    {
      int currentResultIndex = it->m_RuleIndex;
      //faz todos que resultam na mesma producao
      int count = 0;

      while (currentResultIndex == it->m_RuleIndex)
      {
        if (count == 0)
        {
          os  << TAB__2;

          if (rulecount > 0)
          {
            os  <<  L"else ";
          }

          os  <<  L"if (token == " <<  tokenPrefix << it->m_pTerminal->GetName();
        }
        else
        {
          os   << L" ||\n";
          os   << TAB__2 << L"    token == "  << tokenPrefix << it->m_pTerminal->GetName();
        }

        auto itcopy = it;
        it++;
        count++;

        if (it == map.end() ||
            currentResultIndex != it->m_RuleIndex)
        {
          os << L")\n"; //fecha if
          const Production& production = g.GetProduction(itcopy->m_RuleIndex);
          os << TAB__2 << L"{\n";
          os << TAB___3 ;
          os << L"//";
          Print(os , production);
          os << L"\n";
          PrintProduction(os, production, g, tokenPrefix, TAB___3);
          os << TAB__2 << L"}\n";
          break;
        }

        if (it == map.end())
        {
          break;
        }
      }

      /*   if (it != map.end())
         {
             it++;
         }
         */
      if (it == map.end())
      {
        break;
      }

      rulecount++;
    } //regra

    os << TAB__2 << L"else\n";
    os << TAB__2 << L"{\n";
    os << TAB___3 << L"OnError(ctx, ErrorCodeUnexpectedToken);\n";
    os << TAB__2 << L"}\n";
    os << TAB_1 << L"}\n\n";
  }

  os << L"} //namespace " << g.GetLanguageName() << L"\n";
}


static void GenerateDescRec3(std::wostream& os,
                      Grammar& g,
                      MMap& map,
                      const std::wstring& tokenPrefix)
{
  if (map.empty())
  {
    return;
  }

  PrintGeneratedFileHeader(os);
  PrintGeneratedFileLicense(os);

  os << L"#pragma once\n";
  os << L"\n";
  os << L"#include <string>\n";
  os << L"#include \"tokenizer.h\"\n";
  os << L"#include \"" << g.GetModuleName() << L"Lex.h\"\n";
  os << L"\n";
  os << L"\n";
  os << L"namespace " << g.GetLanguageName() << L"\n";
  os << L"{\n";
  //PrintOutputClass(os, g);
  PrintFowardDeclarations(os, g, map);
  int i = 0;
  int sub = 0;
  int currentRuleIndex = -1;
  auto it = map.begin();

  for (; it != map.end();)
  {
    int currentRuleIndex = it->m_pNotTerminal->GetIndex();
    //Faz todos desta regra (até ela mudar)
    os << TAB_1 <<  L"void " << "Parse_" << it->m_pNotTerminal->GetName() << L"(Context& ctx)\n";
    os << TAB_1 << L"{\n";
    int sub = 0;
    bool allsame = false;
    bool firstPrinted = false;

    if (PreAnalise(map, it, allsame) == 1)
    {
      //se so tem um nao precisa testar pelo token pois sempre haver um teste
      //a seguir de qualquer forma
      const Production& production = g.GetProduction(it->m_RuleIndex);
      os << TAB__2 << L"//";
      Print(os , production);
      os << L"\n";
      PrintProduction(os, production, g, tokenPrefix, TAB__2);
      it++;
    }
    else
    {
      while (it->m_pNotTerminal->GetIndex() == currentRuleIndex)
      {
        //se todos forem iguais nao testa pelo token
        //e so imprimi o primeiro que eh igual aos outros
        if (!allsame)
        {
          if (sub == 0)
          {
            os  << TAB__2 <<  L"if (IsToken(ctx, "  << tokenPrefix << it->m_pTerminal->GetName() << L"))\n" ;
          }
          else
          {
            os   << TAB__2 << L"else if (IsToken(ctx, " <<  tokenPrefix << it->m_pTerminal->GetName() << L"))\n" ;
          }
        }

        const Production& production = g.GetProduction(it->m_RuleIndex);

        if (!allsame)
        {
          os << TAB__2 << L"{\n";
        }

        if (!allsame || (allsame && !firstPrinted))
        {
          os << (!allsame ? TAB___3 : TAB__2);
          os << L"//";
          Print(os , production);
          os << L"\n";
          PrintProduction(os, production, g, tokenPrefix, !allsame ? TAB___3 : TAB__2);

          if (!allsame)
          {
            os << TAB__2 << L"}\n";
          }
        }

        sub++;
        it++;

        if (it == map.end())
        {
          break;
        }

        firstPrinted = true;
      }
    }

    os << TAB_1 << L"}\n\n";
  }

  os << L"} //namespace " << g.GetLanguageName() << L"\n";
}

