//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Sep 27 2013
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cassert>
#include <string>
#include "tokenizer.h"
#include "tklgenDFA.h"
#include "Grammar.h"

#include "FileStream.h"

namespace tklgen
{
    enum ParserErrorCode
    {
        ParserErrorCodeModule,
        ParserErrorCodeScannerError,
        ParserErrorCodeTokenUnexpected,
        ParserErrorCodeDeclarationExpexted,
    };

    const wchar_t* GetErrorString(ParserErrorCode e);
    class Context;
    void OnError(Context&, ParserErrorCode);

    class ParserErrorException : public std::exception
    {
    public:
        int m_Line;
        int m_Col;
        ParserErrorCode m_Error;
        ParserErrorException(int line, int col, ParserErrorCode error)
            : m_Line(line), m_Col(col), m_Error(error)
        {
        }
    };


    class Context
    {
    public:
        FileStream& m_Stream;

        Tokens m_CurrentToken;
        std::wstring m_lexeme;
        Grammar& m_grammar;

        Context(Grammar& grammar, FileStream& stream) :  m_grammar(grammar), m_Stream(stream)
        {
            if (!NextToken<DFA>(
                        stream,
                        m_lexeme,
                        m_CurrentToken))
            {
                assert(false);
            }
        }
    };

    inline void OnError(Context& context, ParserErrorCode er)
    {
        throw ParserErrorException(GetLine(context.m_Stream),
                                   GetCol(context.m_Stream),
                                   er);
    }

    inline Tokens GetToken(Context& context)
    {
        return context.m_CurrentToken;
    }

    inline bool Match(Context& context, Tokens tk)
    {
        if (tk != context.m_CurrentToken)
        {
            OnError(context, ParserErrorCodeScannerError);
            return false;
        }

        if (!NextToken<DFA>(
                    context.m_Stream,
                    context.m_lexeme,
                    context.m_CurrentToken))
        {
        }

        return true;
    }


    void Parse(const wchar_t* file, Grammar& grammar);
} // namespace
