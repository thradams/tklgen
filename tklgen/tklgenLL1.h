// Generated by tkgen and llgen - Version 2012-03-02
// llgen was developed by Thiago Adams
// www.thradams.com
//
// Copyright (C) 2009, Thiago Adams (thiago.adams@gmail.com)
// http://www.thradams.com/
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
#pragma once

#include <string>
#include "tokenizer.h"
#include "tklgenDFA.h"


namespace tklgen
{
    template <class TokenizerStreamT>
    class Output
    {
        typedef Tokenizer<tklgen::DFA, TokenizerStreamT> Scanner;
        Scanner m_scanner;
        
        tklgen::Tokens m_CurrentToken;
        std::wstring m_lexeme;
        
    public:
        Output(TokenizerStreamT& s) : m_scanner(s)
        {
            if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
            {
            }
        }

        tklgen::Tokens Token() const
        {
             return m_CurrentToken;
        }
        
        void Match(tklgen::Tokens tk)
        {
             if (tk != m_CurrentToken)
             {
                 throw std::runtime_error("token not expected");
             }
             if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
             {
             }
        }
        
        void Action_ModuleName()
        {
        }

        void Action_LanguageName()
        {
        }

        void Action_TokenName()
        {
        }

        void Action_TokenEnd()
        {
        }

        void Action_SyntaxName()
        {
        }

        void Action_PrintAnd()
        {
        }

        void Action_PrintOr()
        {
        }

        void Action_PrintOptional()
        {
        }

        void Action_PrintZeroOrMore()
        {
        }

        void Action_PrintOneOrMore()
        {
        }

        void Action_PrintChar()
        {
        }

        void Action_PrintName()
        {
        }

        void Action_PrintAny()
        {
        }

        void Action_PrintString()
        {
        }

        void Action_PrintRange()
        {
        }

        void Action_CloseProduction()
        {
        }

        void Action_PrintEmptyProduction()
        {
        }

        void Action_PrintAction()
        {
        }

    };
    
    typedef Output<FileTokenizerStream<wchar_t>> Context;
    
    
    //forward declarations 
    void Parse_ModuleBody(Context&);
    void Parse_LanguageBody(Context&);
    void Parse_TokenDeclaration(Context&);
    void Parse_SyntaxDeclaration(Context&);
    void Parse_InterleaveDeclaration(Context&);
    void Parse_ZeroOrMoreOrF(Context&);
    void Parse_OrF(Context&);
    void Parse_V(Context&);
    void Parse_P(Context&);
    void Parse_OptOperator(Context&);
    void Parse_RangeOpt(Context&);
    void Parse_SyntaxExpressionSingle(Context&);
    void Parse_SyntaxExpressionMoreSingle(Context&);
    void Parse_SyntaxExpressionItem(Context&);
    void Parse_SyntaxExpressionSingleFollow(Context&);
    void Parse_SyntaxExpressionAction(Context&);


    void Parse_ModuleBody(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkKeywordModule)
        {
            //ModuleBody => KeywordModule Identifier LeftCurlyBracketCharacter RightCurlyBracketCharacter 
            ctx.Match(tklgen::tkKeywordModule);
            ctx.Match(tklgen::tkIdentifier);
            ctx.Match(tklgen::tkLeftCurlyBracketCharacter);
            ctx.Match(tklgen::tkRightCurlyBracketCharacter);
        }
    }

    void Parse_LanguageBody(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkKeywordLanguage)
        {
            //LanguageBody => KeywordLanguage Identifier LeftCurlyBracketCharacter RightCurlyBracketCharacter 
            ctx.Match(tklgen::tkKeywordLanguage);
            ctx.Match(tklgen::tkIdentifier);
            ctx.Match(tklgen::tkLeftCurlyBracketCharacter);
            ctx.Match(tklgen::tkRightCurlyBracketCharacter);
        }
    }

    void Parse_TokenDeclaration(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkKeywordToken)
        {
            //TokenDeclaration => KeywordToken Identifier EqualsCharacter SemicolonCharacter 
            ctx.Match(tklgen::tkKeywordToken);
            ctx.Match(tklgen::tkIdentifier);
            ctx.Match(tklgen::tkEqualsCharacter);
            ctx.Match(tklgen::tkSemicolonCharacter);
        }
    }

    void Parse_SyntaxDeclaration(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkKeywordSyntax)
        {
            //SyntaxDeclaration => KeywordSyntax Identifier EqualsCharacter SemicolonCharacter 
            ctx.Match(tklgen::tkKeywordSyntax);
            ctx.Match(tklgen::tkIdentifier);
            ctx.Match(tklgen::tkEqualsCharacter);
            ctx.Match(tklgen::tkSemicolonCharacter);
        }
    }

    void Parse_InterleaveDeclaration(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkKeywordInterleave)
        {
            //InterleaveDeclaration => KeywordInterleave Identifier EqualsCharacter TokenExpression SemicolonCharacter 
            ctx.Match(tklgen::tkKeywordInterleave);
            ctx.Match(tklgen::tkIdentifier);
            ctx.Match(tklgen::tkEqualsCharacter);
            Parse_TokenExpression(ctx);
            ctx.Match(tklgen::tkSemicolonCharacter);
        }
    }

    void Parse_ZeroOrMoreOrF(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkVerticalLineCharacter)
        {
            //ZeroOrMoreOrF => OrF ZeroOrMoreOrF 
            Parse_OrF(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
    }

    void Parse_OrF(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkVerticalLineCharacter)
        {
            //OrF => VerticalLineCharacter F 
            ctx.Match(tklgen::tkVerticalLineCharacter);
            Parse_F(ctx);
        }
    }

    void Parse_V(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkKeywordAny)
        {
            //V => KeywordAny 
            ctx.Match(tklgen::tkKeywordAny);
        }
        else if (ctx.Token() == tklgen::tkLiteralChar)
        {
            //V => LiteralChar 
            ctx.Match(tklgen::tkLiteralChar);
        }
        else if (ctx.Token() == tklgen::tkIdentifier)
        {
            //V => Identifier 
            ctx.Match(tklgen::tkIdentifier);
        }
        else if (ctx.Token() == tklgen::tkStringLiteral)
        {
            //V => StringLiteral 
            ctx.Match(tklgen::tkStringLiteral);
        }
    }

    void Parse_P(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkLeftParenthesisCharacter)
        {
            //P => LeftParenthesisCharacter TokenExpression RightParenthesisCharacter 
            ctx.Match(tklgen::tkLeftParenthesisCharacter);
            Parse_TokenExpression(ctx);
            ctx.Match(tklgen::tkRightParenthesisCharacter);
        }
    }

    void Parse_OptOperator(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkPlusCharacter)
        {
            //OptOperator => PlusCharacter 
            ctx.Match(tklgen::tkPlusCharacter);
        }
        else if (ctx.Token() == tklgen::tkQuestionMarkCharacter)
        {
            //OptOperator => QuestionMarkCharacter 
            ctx.Match(tklgen::tkQuestionMarkCharacter);
        }
        else if (ctx.Token() == tklgen::tkAsteriskCharacter)
        {
            //OptOperator => AsteriskCharacter 
            ctx.Match(tklgen::tkAsteriskCharacter);
        }
    }

    void Parse_RangeOpt(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkRangeSeparator)
        {
            //RangeOpt => RangeSeparator LiteralChar 
            ctx.Match(tklgen::tkRangeSeparator);
            ctx.Match(tklgen::tkLiteralChar);
        }
    }

    void Parse_SyntaxExpressionSingle(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkKeywordEmpty)
        {
            //SyntaxExpressionSingle => KeywordEmpty 
            ctx.Match(tklgen::tkKeywordEmpty);
        }
    }

    void Parse_SyntaxExpressionMoreSingle(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkVerticalLineCharacter)
        {
            //SyntaxExpressionMoreSingle => VerticalLineCharacter SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            ctx.Match(tklgen::tkVerticalLineCharacter);
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
    }

    void Parse_SyntaxExpressionItem(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkLiteralChar)
        {
            //SyntaxExpressionItem => LiteralChar 
            ctx.Match(tklgen::tkLiteralChar);
        }
        else if (ctx.Token() == tklgen::tkIdentifier)
        {
            //SyntaxExpressionItem => Identifier 
            ctx.Match(tklgen::tkIdentifier);
        }
        else if (ctx.Token() == tklgen::tkStringLiteral)
        {
            //SyntaxExpressionItem => StringLiteral 
            ctx.Match(tklgen::tkStringLiteral);
        }
    }

    void Parse_SyntaxExpressionSingleFollow(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkLiteralChar)
        {
            //SyntaxExpressionSingleFollow => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tklgen::tkIdentifier)
        {
            //SyntaxExpressionSingleFollow => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tklgen::tkStringLiteral)
        {
            //SyntaxExpressionSingleFollow => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
    }

    void Parse_SyntaxExpressionAction(Context& ctx)
    {
        if (ctx.Token() == tklgen::tkLeftCurlyBracketCharacter)
        {
            //SyntaxExpressionAction => LeftCurlyBracketCharacter Identifier RightCurlyBracketCharacter 
            ctx.Match(tklgen::tkLeftCurlyBracketCharacter);
            ctx.Match(tklgen::tkIdentifier);
            ctx.Match(tklgen::tkRightCurlyBracketCharacter);
        }
    }
} //namespace tklgen
