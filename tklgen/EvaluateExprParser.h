//////////////////////////////////////////////////////////////////////////////
// Generated by TKLGEN - Version Oct 27 2014
// Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
// www.thradams.com
//
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
//////////////////////////////////////////////////////////////////////////////
#pragma once

#include <cassert>
#include <string>
#include "tokenizer.h"
#include "EvaluateExprLex.h"


#include "FileStream.h"

namespace EvaluateExpr
{
    enum ErrorCode
    {
        ErrorCodeUnexpectedEof,
        ErrorCodeUnexpectedToken
    };

    class Context;
    void OnError(Context&, ErrorCode);

    class ParserException : public std::exception
    {
    public:
        int m_Line;
        int m_Col;
        ErrorCode m_Error;
        ParserException(int line, int col, ErrorCode error)
            : m_Line(line), m_Col(col), m_Error(error)
        {
        }
    };


    class Context
    {
    public:
        FileStream& m_Stream;

        Tokens m_CurrentToken;
        std::wstring m_lexeme;
        
        Context(FileStream& stream) : m_Stream(stream)
        {
            if (!NextToken<DFA>(
                        stream,
                        m_lexeme,
                        m_CurrentToken))
            {
              assert(false);
            }
        }
    };

    inline void OnError(Context& context, ErrorCode er)
    {
        throw ParserException(GetLine(context.m_Stream),
                              GetCol(context.m_Stream),
                              er);
    }

    inline Tokens GetToken(Context& context)
    {
        return context.m_CurrentToken;
    }

    inline bool Match(Context& context, Tokens tk)
    {
        if (tk != context.m_CurrentToken)
        {
            OnError(context, ErrorCodeUnexpectedToken);
            return false;
        }

        if (!NextToken<DFA>(
                    context.m_Stream,
                    context.m_lexeme,
                    context.m_CurrentToken))
        {
        }
        return true;
    }

    //Forward declarations for actions

    void Parse_Main(Context&);
} // namespace
