/*
 * Generated by TKLGEN - VersionApr 24 2015
 * Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
 * www.thradams.com
 *
 */

#include "stdafx.h"
#include <assert.h>

#include "EvalLex.h"
#include "EvalParser.h"


#include "sstream.h"




typedef enum 
{
  ErrorCodeUnexpectedToken
} ErrorCode;

#define IFER(x) if (!(x)) return 0;

/*Context*/


static int Eval_Context_Init(struct Eval_Context* p)
{
    p->lexeme[0] = 0;
    p->stream = 0;
    p->token = (enum Eval_Tokens) 0;
    p->pData = 0;
    return 1;
}

void OnError(struct Eval_Context* context, ErrorCode er)
{
}

static int ReadNextToken(struct Eval_Context* context)
{
    int r = Eval_NextToken(context->stream,
                        context->lexeme,
                        sizeof(context->lexeme)/sizeof(context->lexeme[0]),
                        &context->token);

    switch (r)
    {
    case -1:
        OnError(context, ErrorCodeUnexpectedToken);
        break;
    case -2:
        /*eof*/
        break;
    }

    return r;
}

int Eval_Context_AttachStream(struct Eval_Context* p, struct sstream* ss)
{
    p->stream = ss;
    return ReadNextToken(p);
}


static int Match(struct Eval_Context* context, enum Eval_Tokens tk)
{
    if (tk != context->token)
    {
        OnError(context, ErrorCodeUnexpectedToken);
        return 0;
    }
    return ReadNextToken(context);
}


int Parse_Main(struct Eval_Context* ctx);

int Eval_Parse(struct sstream* ss, Eval_OnAction action, void* context)
{
  struct Eval_Context ctx;
  Eval_Context_Init(&ctx);
  ctx.pData = context;
  ctx.on_action = action;
  Eval_Context_AttachStream(&ctx, ss);

  return Parse_Main(&ctx);
}
/*forward declarations*/ 
int Parse_C(struct Eval_Context* ctx);
int Parse_Main(struct Eval_Context* ctx);
int Parse_T2(struct Eval_Context* ctx);
int Parse_D(struct Eval_Context* ctx);
int Parse_C2(struct Eval_Context* ctx);
int Parse_E(struct Eval_Context* ctx);
int Parse_D2(struct Eval_Context* ctx);
int Parse_T(struct Eval_Context* ctx);
int Parse_E2(struct Eval_Context* ctx);
int Parse_F(struct Eval_Context* ctx);
int Parse_P(struct Eval_Context* ctx);
int Parse_FOpt(struct Eval_Context* ctx);


int Parse_C(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKIdentifier ||
        token == TKMinus ||
        token == TKOpen ||
        token == TKNumber)
    {
        /*C => D C2 */
        IFER(Parse_D(ctx));
        IFER(Parse_C2(ctx));
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_Main(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKIdentifier ||
        token == TKMinus ||
        token == TKOpen ||
        token == TKNumber)
    {
        /*Main => C EndMark */
        IFER(Parse_C(ctx));
        IFER(Match(ctx, TKEndMark));
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_T2(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKMulti)
    {
        /*T2 => Multi F T2 */
        IFER(Match(ctx, TKMulti));
        IFER(Parse_F(ctx));
        IFER(ctx->on_action(PrintMulti, ctx));
        IFER(Parse_T2(ctx));
    }
    else if (token == TKDiv)
    {
        /*T2 => Div F T2 */
        IFER(Match(ctx, TKDiv));
        IFER(Parse_F(ctx));
        IFER(ctx->on_action(PrintDiv, ctx));
        IFER(Parse_T2(ctx));
    }
    else if (token == TKEndMark ||
        token == TKPlus ||
        token == TKMinus ||
        token == TKMulti ||
        token == TKDiv ||
        token == TKPower ||
        token == TKGreaterThan ||
        token == TKClose ||
        token == TKEqual ||
        token == TKDiferentThan ||
        token == TKLessThan ||
        token == TKGreaterEqualThan ||
        token == TKLessEqualThan ||
        token == TKAnd ||
        token == TKOr)
    {
        /*T2 => Epsilon */
        return 2; /*opt*/
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_D(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKIdentifier ||
        token == TKMinus ||
        token == TKOpen ||
        token == TKNumber)
    {
        /*D => E D2 */
        IFER(Parse_E(ctx));
        IFER(Parse_D2(ctx));
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_C2(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKAnd)
    {
        /*C2 => And D C2 */
        IFER(Match(ctx, TKAnd));
        IFER(Parse_D(ctx));
        IFER(ctx->on_action(PrintAnd, ctx));
        IFER(Parse_C2(ctx));
    }
    else if (token == TKOr)
    {
        /*C2 => Or D C2 */
        IFER(Match(ctx, TKOr));
        IFER(Parse_D(ctx));
        IFER(ctx->on_action(PrintOr, ctx));
        IFER(Parse_C2(ctx));
    }
    else if (token == TKEndMark)
    {
        /*C2 => Epsilon */
        return 2; /*opt*/
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_E(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKIdentifier ||
        token == TKMinus ||
        token == TKOpen ||
        token == TKNumber)
    {
        /*E => T E2 */
        IFER(Parse_T(ctx));
        IFER(Parse_E2(ctx));
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_D2(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKGreaterThan)
    {
        /*D2 => GreaterThan E D2 */
        IFER(Match(ctx, TKGreaterThan));
        IFER(Parse_E(ctx));
        IFER(ctx->on_action(PrintGreaterThan, ctx));
        IFER(Parse_D2(ctx));
    }
    else if (token == TKLessThan)
    {
        /*D2 => LessThan E D2 */
        IFER(Match(ctx, TKLessThan));
        IFER(Parse_E(ctx));
        IFER(ctx->on_action(PrintLessThan, ctx));
        IFER(Parse_D2(ctx));
    }
    else if (token == TKLessEqualThan)
    {
        /*D2 => LessEqualThan E D2 */
        IFER(Match(ctx, TKLessEqualThan));
        IFER(Parse_E(ctx));
        IFER(ctx->on_action(PrintLessEqualThan, ctx));
        IFER(Parse_D2(ctx));
    }
    else if (token == TKGreaterEqualThan)
    {
        /*D2 => GreaterEqualThan E D2 */
        IFER(Match(ctx, TKGreaterEqualThan));
        IFER(Parse_E(ctx));
        IFER(ctx->on_action(PrintGreaterEqualThan, ctx));
        IFER(Parse_D2(ctx));
    }
    else if (token == TKEqual)
    {
        /*D2 => Equal E D2 */
        IFER(Match(ctx, TKEqual));
        IFER(Parse_E(ctx));
        IFER(ctx->on_action(PrintEquals, ctx));
        IFER(Parse_D2(ctx));
    }
    else if (token == TKDiferentThan)
    {
        /*D2 => DiferentThan E D2 */
        IFER(Match(ctx, TKDiferentThan));
        IFER(Parse_E(ctx));
        IFER(ctx->on_action(PrintNotEqual, ctx));
        IFER(Parse_D2(ctx));
    }
    else if (token == TKEndMark ||
        token == TKAnd ||
        token == TKOr)
    {
        /*D2 => Epsilon */
        return 2; /*opt*/
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_T(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKIdentifier ||
        token == TKMinus ||
        token == TKOpen ||
        token == TKNumber)
    {
        /*T => F T2 */
        IFER(Parse_F(ctx));
        IFER(Parse_T2(ctx));
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_E2(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKPlus)
    {
        /*E2 => Plus T E2 */
        IFER(Match(ctx, TKPlus));
        IFER(Parse_T(ctx));
        IFER(ctx->on_action(PrintPlus, ctx));
        IFER(Parse_E2(ctx));
    }
    else if (token == TKMinus)
    {
        /*E2 => Minus T E2 */
        IFER(Match(ctx, TKMinus));
        IFER(Parse_T(ctx));
        IFER(ctx->on_action(PrintMinus, ctx));
        IFER(Parse_E2(ctx));
    }
    else if (token == TKEndMark ||
        token == TKGreaterThan ||
        token == TKClose ||
        token == TKEqual ||
        token == TKDiferentThan ||
        token == TKLessThan ||
        token == TKGreaterEqualThan ||
        token == TKLessEqualThan ||
        token == TKAnd ||
        token == TKOr)
    {
        /*E2 => Epsilon */
        return 2; /*opt*/
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_F(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKIdentifier ||
        token == TKMinus ||
        token == TKOpen ||
        token == TKNumber)
    {
        /*F => P FOpt */
        IFER(Parse_P(ctx));
        IFER(Parse_FOpt(ctx));
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_P(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKNumber)
    {
        /*P => Number */
        IFER(ctx->on_action(PrintLexeme, ctx));
        IFER(Match(ctx, TKNumber));
    }
    else if (token == TKIdentifier)
    {
        /*P => Identifier */
        IFER(ctx->on_action(PrintLexeme, ctx));
        IFER(Match(ctx, TKIdentifier));
    }
    else if (token == TKOpen)
    {
        /*P => Open E Close */
        IFER(Match(ctx, TKOpen));
        IFER(Parse_E(ctx));
        IFER(Match(ctx, TKClose));
    }
    else if (token == TKMinus)
    {
        /*P => Minus T */
        IFER(Match(ctx, TKMinus));
        IFER(Parse_T(ctx));
        IFER(ctx->on_action(PrintNeg, ctx));
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

int Parse_FOpt(struct Eval_Context* ctx)
{
    enum Eval_Tokens token = ctx->token; 

    if (token == TKPower)
    {
        /*FOpt => Power F */
        IFER(Match(ctx, TKPower));
        IFER(Parse_F(ctx));
        IFER(ctx->on_action(PrintPower, ctx));
    }
    else if (token == TKEndMark ||
        token == TKPlus ||
        token == TKMinus ||
        token == TKMulti ||
        token == TKDiv ||
        token == TKPower ||
        token == TKGreaterThan ||
        token == TKClose ||
        token == TKEqual ||
        token == TKDiferentThan ||
        token == TKLessThan ||
        token == TKGreaterEqualThan ||
        token == TKLessEqualThan ||
        token == TKAnd ||
        token == TKOr)
    {
        /*FOpt => Epsilon */
        return 2; /*opt*/
    }
    else
    {
        OnError(ctx, ErrorCodeUnexpectedToken);
        return 0;
    }

    return 1;
}

