/*
 * Generated by TKLGEN - VersionApr 24 2015
 * Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
 * www.thradams.com
 *
 */

#include "EvalLex.h"
#include <assert.h>

const wchar_t* Eval_Tokens_ToString(enum Eval_Tokens e)
{
    switch(e)
    {
    case TKIdentifier: return L"Identifier";
    case TKPlus: return L"Plus";
    case TKMinus: return L"Minus";
    case TKMulti: return L"Multi";
    case TKDiv: return L"Div";
    case TKPower: return L"Power";
    case TKOpen: return L"Open";
    case TKClose: return L"Close";
    case TKEqual: return L"Equal";
    case TKGreaterThan: return L"GreaterThan";
    case TKLessThan: return L"LessThan";
    case TKGreaterEqualThan: return L"GreaterEqualThan";
    case TKLessEqualThan: return L"LessEqualThan";
    case TKDiferentThan: return L"DiferentThan";
    case TKEnd: return L"End";
    case TKAnd: return L"And";
    case TKOr: return L"Or";
    case TKEndMark: return L"EndMark";
    case TKNumber: return L"Number";
    case TKBlanks: return L"Blanks";
    default:break;
    }
    return L"";
}

static int Eval_GetNext(int state, wchar_t ch)
{
    switch (state)
    {
        case 0:
        if (ch == L'\0')
            return 1;
        else if (ch >= L'\t' && ch <= L'\n')
            return 2;
        else if (ch == L'\r')
            return 2;
        else if (ch == L' ')
            return 2;
        else if (ch == L'!')
            return 3;
        else if (ch == L'$')
            return 4;
        else if (ch == L'(')
            return 5;
        else if (ch == L')')
            return 6;
        else if (ch == L'*')
            return 7;
        else if (ch == L'+')
            return 8;
        else if (ch == L'-')
            return 9;
        else if (ch == L'/')
            return 10;
        else if (ch >= L'0' && ch <= L'9')
            return 11;
        else if (ch == L';')
            return 12;
        else if (ch == L'<')
            return 13;
        else if (ch == L'=')
            return 14;
        else if (ch == L'>')
            return 15;
        else if (ch >= L'A' && ch <= L'Z')
            return 4;
        else if (ch == L'^')
            return 16;
        else if (ch == L'_')
            return 4;
        else if (ch == L'a')
            return 17;
        else if (ch >= L'b' && ch <= L'n')
            return 4;
        else if (ch == L'o')
            return 18;
        else if (ch >= L'p' && ch <= L'z')
            return 4;
        break;
        case 1:
        /* end state for TKEndMark*/
        break;
        case 2:
        if (ch >= L'\t' && ch <= L'\n')
            return 2;
        else if (ch == L'\r')
            return 2;
        else if (ch == L' ')
            return 2;
        /* end state for TKBlanks*/
        break;
        case 3:
        if (ch == L'=')
    return 20;
        break;
        case 4:
        if (ch == L'$')
            return 4;
        else if (ch >= L'0' && ch <= L'9')
            return 4;
        else if (ch == L':')
            return 21;
        else if (ch >= L'A' && ch <= L'Z')
            return 4;
        else if (ch == L'_')
            return 4;
        else if (ch >= L'a' && ch <= L'z')
            return 4;
        break;
        case 5:
        /* end state for TKOpen*/
        break;
        case 6:
        /* end state for TKClose*/
        break;
        case 7:
        /* end state for TKMulti*/
        break;
        case 8:
        /* end state for TKPlus*/
        break;
        case 9:
        /* end state for TKMinus*/
        break;
        case 10:
        /* end state for TKDiv*/
        break;
        case 11:
        if (ch == L'.')
            return 22;
        else if (ch >= L'0' && ch <= L'9')
            return 11;
        else if (ch == L'E')
            return 23;
        else if (ch == L'e')
            return 23;
        /* end state for TKNumber*/
        break;
        case 12:
        /* end state for TKEnd*/
        break;
        case 13:
        if (ch == L'=')
            return 24;
        /* end state for TKLessThan*/
        break;
        case 14:
        /* end state for TKEqual*/
        break;
        case 15:
        if (ch == L'=')
            return 25;
        /* end state for TKGreaterThan*/
        break;
        case 16:
        /* end state for TKPower*/
        break;
        case 17:
        if (ch == L'$')
            return 4;
        else if (ch >= L'0' && ch <= L'9')
            return 4;
        else if (ch == L':')
            return 21;
        else if (ch >= L'A' && ch <= L'Z')
            return 4;
        else if (ch == L'_')
            return 4;
        else if (ch >= L'a' && ch <= L'm')
            return 4;
        else if (ch == L'n')
            return 26;
        else if (ch >= L'o' && ch <= L'z')
            return 4;
        break;
        case 18:
        if (ch == L'$')
            return 4;
        else if (ch >= L'0' && ch <= L'9')
            return 4;
        else if (ch == L':')
            return 21;
        else if (ch >= L'A' && ch <= L'Z')
            return 4;
        else if (ch == L'_')
            return 4;
        else if (ch >= L'a' && ch <= L'q')
            return 4;
        else if (ch == L'r')
            return 27;
        else if (ch >= L's' && ch <= L'z')
            return 4;
        break;
        case 19:
            return -1; 
        break;
        case 20:
        /* end state for TKDiferentThan*/
        break;
        case 21:
        if (ch == L'$')
            return 28;
        else if (ch >= L'A' && ch <= L'Z')
            return 28;
        else if (ch == L'[')
            return 29;
        else if (ch == L'_')
            return 28;
        else if (ch >= L'a' && ch <= L'z')
            return 28;
        break;
        case 22:
        if (ch >= L'0' && ch <= L'9')
            return 30;
        break;
        case 23:
        if (ch == L'+')
            return 31;
        else if (ch == L'-')
            return 31;
        else if (ch >= L'0' && ch <= L'9')
            return 32;
        break;
        case 24:
        /* end state for TKLessEqualThan*/
        break;
        case 25:
        /* end state for TKGreaterEqualThan*/
        break;
        case 26:
        if (ch == L'$')
            return 4;
        else if (ch >= L'0' && ch <= L'9')
            return 4;
        else if (ch == L':')
            return 21;
        else if (ch >= L'A' && ch <= L'Z')
            return 4;
        else if (ch == L'_')
            return 4;
        else if (ch >= L'a' && ch <= L'c')
            return 4;
        else if (ch == L'd')
            return 33;
        else if (ch >= L'e' && ch <= L'z')
            return 4;
        break;
        case 27:
        if (ch == L'$')
            return 4;
        else if (ch >= L'0' && ch <= L'9')
            return 4;
        else if (ch == L':')
            return 21;
        else if (ch >= L'A' && ch <= L'Z')
            return 4;
        else if (ch == L'_')
            return 4;
        else if (ch >= L'a' && ch <= L'z')
            return 4;
        /* end state for TKOr*/
        break;
        case 28:
        if (ch == L'$')
            return 28;
        else if (ch == L'.')
            return 21;
        else if (ch >= L'0' && ch <= L'9')
            return 28;
        else if (ch >= L'A' && ch <= L'Z')
            return 28;
        else if (ch == L'_')
            return 28;
        else if (ch >= L'a' && ch <= L'z')
            return 28;
        /* end state for TKIdentifier*/
        break;
        case 29:
        if (ch >= L'!' && ch <= L'Z')
            return 34;
        else if (ch == L'\\')
            return 34;
        else if (ch >= L'^' && ch <= L'\u00a0')
            return 34;
        break;
        case 30:
        if (ch == L'E')
            return 23;
        else if (ch == L'e')
            return 23;
        /* end state for TKNumber*/
        break;
        case 31:
        if (ch >= L'0' && ch <= L'9')
            return 32;
        break;
        case 32:
        /* end state for TKNumber*/
        break;
        case 33:
        if (ch == L'$')
            return 4;
        else if (ch >= L'0' && ch <= L'9')
            return 4;
        else if (ch == L':')
            return 21;
        else if (ch >= L'A' && ch <= L'Z')
            return 4;
        else if (ch == L'_')
            return 4;
        else if (ch >= L'a' && ch <= L'z')
            return 4;
        /* end state for TKAnd*/
        break;
        case 34:
        if (ch >= L'!' && ch <= L'Z')
            return 34;
        else if (ch == L'\\')
            return 34;
        else if (ch == L']')
            return 35;
        else if (ch >= L'^' && ch <= L'\u00a0')
            return 34;
        break;
        case 35:
        if (ch == L'.')
            return 21;
        /* end state for TKIdentifier*/
        break;
    } /*switch*/
    return -1;
}

static int Eval_IsInterleave(enum Eval_Tokens tk)
{
    return tk == TKBlanks;
}

static int Eval_GetTokenFromState(int state, enum Eval_Tokens* tk)
{
    switch (state)
    {
        case 1: *tk = TKEndMark; break;
        case 2: *tk = TKBlanks; break;
        case 5: *tk = TKOpen; break;
        case 6: *tk = TKClose; break;
        case 7: *tk = TKMulti; break;
        case 8: *tk = TKPlus; break;
        case 9: *tk = TKMinus; break;
        case 10: *tk = TKDiv; break;
        case 11: *tk = TKNumber; break;
        case 12: *tk = TKEnd; break;
        case 13: *tk = TKLessThan; break;
        case 14: *tk = TKEqual; break;
        case 15: *tk = TKGreaterThan; break;
        case 16: *tk = TKPower; break;
        case 20: *tk = TKDiferentThan; break;
        case 24: *tk = TKLessEqualThan; break;
        case 25: *tk = TKGreaterEqualThan; break;
        case 27: *tk = TKOr; break;
        case 28: *tk = TKIdentifier; break;
        case 30: *tk = TKNumber; break;
        case 32: *tk = TKNumber; break;
        case 33: *tk = TKAnd; break;
        case 35: *tk = TKIdentifier; break;
        default:
            return 0;
    }
    return 1;
}

int Eval_NextTokenNoInterleave(struct sstream* stream,
    wchar_t* buffer,
    int bufferSize,
    enum Eval_Tokens* tk)
{
    if (bufferSize <= 0)
    {
        assert(0);
        return 0;
    }
    buffer[0] = 0;
    int lastGoodState = -2;
    int currentState = 0;
    wchar_t ch;
    int index = 0;
    while (sstream_getwc(stream, &ch))
    {
        currentState = Eval_GetNext(currentState, ch);
        if (currentState == -1)
        {
            sstream_ungetwc(stream, ch);
            break;
        }
        enum Eval_Tokens tk2;
        if (Eval_GetTokenFromState(currentState, &tk2))
        {
            *tk = tk2;
            lastGoodState = currentState;
        }
        if (index < bufferSize)
        {
            buffer[index++] = ch;
        }
        else
        {
            assert(0);
            return 0;
        }
    }
    buffer[index] = 0;
    return lastGoodState;
}

int Eval_NextToken(struct sstream* stream,
    wchar_t* buffer,
    int bufferSize,
    enum Eval_Tokens* tk)
{
    for (;;)
    {
        int r = Eval_NextTokenNoInterleave(stream, buffer, bufferSize, tk);
        if (r < 0)
        {
            return r;/*error or eof*/
        }
        if (!Eval_IsInterleave(*tk))
        {
            return r;
        }
    }
}