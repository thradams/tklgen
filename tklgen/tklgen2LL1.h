// Generated by tkgen and llgen - Version 2012-03-02
// llgen was developed by Thiago Adams
// www.thradams.com
//
// Copyright (C) 2009, Thiago Adams (thiago.adams@gmail.com)
// http://www.thradams.com/
// Permission to copy, use, modify, sell and distribute this software
// is granted provided this copyright notice appears in all copies.
// This software is provided "as is" without express or implied
// warranty, and with no claim as to its suitability for any purpose.
//
#pragma once

#include <cassert>
#include <string>
#include "tokenizer.h"
#include "tklgen2DFA.h"


namespace tklgen
{
    class Context
    {
    public:
        //returns the current token
        virtual tklgen::Tokens Token() const = 0;
    
        //checks if Token() == tk and then move the current token
        virtual void Match(tklgen::Tokens tk) = 0;
    
        //Actions
    };
    
    
/*
    class YourClass : public tklgen::Context
    {
        typedef Tokenizer<tklgen::DFA, TokenizerStreamT> Scanner;
        Scanner m_scanner;
        
        tklgen::Tokens m_CurrentToken;
        std::wstring m_lexeme;
        
    public:
        YourClass(TokenizerStreamT& s) : m_scanner(s)
        {
            if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
            {
            }
        }

        //returns the current token
        tklgen::Tokens Token() const
        {
             return m_CurrentToken;
        }
        
        //checks if Token() == tk and then move the current token
        void Match(tklgen::Tokens tk)
        {
             if (tk != m_CurrentToken)
             {
                 throw std::runtime_error("token not expected");
             }
             if (!m_scanner.NextToken(m_lexeme, m_CurrentToken))
             {
             }
        }
        
    };
    
*/
    //forward declarations 
    void Parse_Main(Context&);
    void Parse_ModuleBody(Context&);
    void Parse_LanguageBody(Context&);
    void Parse_Declarations(Context&);
    void Parse_Declaration(Context&);
    void Parse_TokenDeclaration(Context&);
    void Parse_SyntaxDeclaration(Context&);
    void Parse_InterleaveDeclaration(Context&);
    void Parse_SyntaxExpressionAction(Context&);
    void Parse_TokenExpression(Context&);
    void Parse_SyntaxExpression(Context&);
    void Parse_T(Context&);
    void Parse_ZeroOrMoreT(Context&);
    void Parse_F(Context&);
    void Parse_ZeroOrMoreOrF(Context&);
    void Parse_OrF(Context&);
    void Parse_P(Context&);
    void Parse_OptOperator(Context&);
    void Parse_V(Context&);
    void Parse_RangeOpt(Context&);
    void Parse_SyntaxExpressionSingle(Context&);
    void Parse_SyntaxExpressionMoreSingle(Context&);
    void Parse_SyntaxExpressionItem(Context&);
    void Parse_SyntaxExpressionSingleFollow(Context&);


    void Parse_Main(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKKeywordModule)
        {
            //Main => ModuleBody 
            Parse_ModuleBody(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_ModuleBody(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKKeywordModule)
        {
            //ModuleBody => KeywordModule Identifier LeftCurlyBracketCharacter LanguageBody RightCurlyBracketCharacter 
            ctx.Match(tklgen::TKKeywordModule);
            ctx.Match(tklgen::TKIdentifier);
            ctx.Match(tklgen::TKLeftCurlyBracketCharacter);
            Parse_LanguageBody(ctx);
            ctx.Match(tklgen::TKRightCurlyBracketCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_LanguageBody(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKKeywordLanguage)
        {
            //LanguageBody => KeywordLanguage Identifier LeftCurlyBracketCharacter Declarations RightCurlyBracketCharacter 
            ctx.Match(tklgen::TKKeywordLanguage);
            ctx.Match(tklgen::TKIdentifier);
            ctx.Match(tklgen::TKLeftCurlyBracketCharacter);
            Parse_Declarations(ctx);
            ctx.Match(tklgen::TKRightCurlyBracketCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_Declarations(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKKeywordInterleave ||
            ctx.Token() == tklgen::TKKeywordSyntax ||
            ctx.Token() == tklgen::TKKeywordToken)
        {
            //Declarations => Declaration Declarations 
            Parse_Declaration(ctx);
            Parse_Declarations(ctx);
        }
        else if (ctx.Token() == tklgen::TKRightCurlyBracketCharacter)
        {
            //Declarations => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_Declaration(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKKeywordToken)
        {
            //Declaration => TokenDeclaration 
            Parse_TokenDeclaration(ctx);
        }
        else if (ctx.Token() == tklgen::TKKeywordSyntax)
        {
            //Declaration => SyntaxDeclaration 
            Parse_SyntaxDeclaration(ctx);
        }
        else if (ctx.Token() == tklgen::TKKeywordInterleave)
        {
            //Declaration => InterleaveDeclaration 
            Parse_InterleaveDeclaration(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_TokenDeclaration(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKKeywordToken)
        {
            //TokenDeclaration => KeywordToken Identifier EqualsCharacter TokenExpression SemicolonCharacter 
            ctx.Match(tklgen::TKKeywordToken);
            ctx.Match(tklgen::TKIdentifier);
            ctx.Match(tklgen::TKEqualsCharacter);
            Parse_TokenExpression(ctx);
            ctx.Match(tklgen::TKSemicolonCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxDeclaration(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKKeywordSyntax)
        {
            //SyntaxDeclaration => KeywordSyntax Identifier EqualsCharacter SyntaxExpression SemicolonCharacter 
            ctx.Match(tklgen::TKKeywordSyntax);
            ctx.Match(tklgen::TKIdentifier);
            ctx.Match(tklgen::TKEqualsCharacter);
            Parse_SyntaxExpression(ctx);
            ctx.Match(tklgen::TKSemicolonCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_InterleaveDeclaration(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKKeywordInterleave)
        {
            //InterleaveDeclaration => KeywordInterleave Identifier EqualsCharacter TokenExpression SemicolonCharacter 
            ctx.Match(tklgen::TKKeywordInterleave);
            ctx.Match(tklgen::TKIdentifier);
            ctx.Match(tklgen::TKEqualsCharacter);
            Parse_TokenExpression(ctx);
            ctx.Match(tklgen::TKSemicolonCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionAction(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLeftCurlyBracketCharacter)
        {
            //SyntaxExpressionAction => LeftCurlyBracketCharacter Identifier RightCurlyBracketCharacter 
            ctx.Match(tklgen::TKLeftCurlyBracketCharacter);
            ctx.Match(tklgen::TKIdentifier);
            ctx.Match(tklgen::TKRightCurlyBracketCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_TokenExpression(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKKeywordAny ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKLeftParenthesisCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //TokenExpression => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpression(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKKeywordEmpty ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKLeftCurlyBracketCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //SyntaxExpression => SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_T(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKKeywordAny ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKLeftParenthesisCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //T => F ZeroOrMoreOrF 
            Parse_F(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_ZeroOrMoreT(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKKeywordAny ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKLeftParenthesisCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //ZeroOrMoreT => T ZeroOrMoreT 
            Parse_T(ctx);
            Parse_ZeroOrMoreT(ctx);
        }
        else if (ctx.Token() == tklgen::TKSemicolonCharacter ||
            ctx.Token() == tklgen::TKRightParenthesisCharacter)
        {
            //ZeroOrMoreT => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_F(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKKeywordAny ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKLeftParenthesisCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //F => P OptOperator 
            Parse_P(ctx);
            Parse_OptOperator(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_ZeroOrMoreOrF(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKVerticalLineCharacter)
        {
            //ZeroOrMoreOrF => OrF ZeroOrMoreOrF 
            Parse_OrF(ctx);
            Parse_ZeroOrMoreOrF(ctx);
        }
        else if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKSemicolonCharacter ||
            ctx.Token() == tklgen::TKKeywordAny ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKLeftParenthesisCharacter ||
            ctx.Token() == tklgen::TKRightParenthesisCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //ZeroOrMoreOrF => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_OrF(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKVerticalLineCharacter)
        {
            //OrF => VerticalLineCharacter F 
            ctx.Match(tklgen::TKVerticalLineCharacter);
            Parse_F(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_P(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKKeywordAny ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //P => V 
            Parse_V(ctx);
        }
        else if (ctx.Token() == tklgen::TKLeftParenthesisCharacter)
        {
            //P => LeftParenthesisCharacter TokenExpression RightParenthesisCharacter 
            ctx.Match(tklgen::TKLeftParenthesisCharacter);
            Parse_TokenExpression(ctx);
            ctx.Match(tklgen::TKRightParenthesisCharacter);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_OptOperator(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKQuestionMarkCharacter)
        {
            //OptOperator => QuestionMarkCharacter 
            ctx.Match(tklgen::TKQuestionMarkCharacter);
        }
        else if (ctx.Token() == tklgen::TKAsteriskCharacter)
        {
            //OptOperator => AsteriskCharacter 
            ctx.Match(tklgen::TKAsteriskCharacter);
        }
        else if (ctx.Token() == tklgen::TKPlusCharacter)
        {
            //OptOperator => PlusCharacter 
            ctx.Match(tklgen::TKPlusCharacter);
        }
        else if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKSemicolonCharacter ||
            ctx.Token() == tklgen::TKKeywordAny ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKVerticalLineCharacter ||
            ctx.Token() == tklgen::TKLeftParenthesisCharacter ||
            ctx.Token() == tklgen::TKRightParenthesisCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //OptOperator => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_V(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar)
        {
            //V => LiteralChar RangeOpt 
            ctx.Match(tklgen::TKLiteralChar);
            Parse_RangeOpt(ctx);
        }
        else if (ctx.Token() == tklgen::TKIdentifier)
        {
            //V => Identifier 
            ctx.Match(tklgen::TKIdentifier);
        }
        else if (ctx.Token() == tklgen::TKKeywordAny)
        {
            //V => KeywordAny 
            ctx.Match(tklgen::TKKeywordAny);
        }
        else if (ctx.Token() == tklgen::TKStringLiteral)
        {
            //V => StringLiteral 
            ctx.Match(tklgen::TKStringLiteral);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_RangeOpt(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKRangeSeparator)
        {
            //RangeOpt => RangeSeparator LiteralChar 
            ctx.Match(tklgen::TKRangeSeparator);
            ctx.Match(tklgen::TKLiteralChar);
        }
        else if (ctx.Token() == tklgen::TKPlusCharacter ||
            ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKSemicolonCharacter ||
            ctx.Token() == tklgen::TKKeywordAny ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKQuestionMarkCharacter ||
            ctx.Token() == tklgen::TKAsteriskCharacter ||
            ctx.Token() == tklgen::TKVerticalLineCharacter ||
            ctx.Token() == tklgen::TKLeftParenthesisCharacter ||
            ctx.Token() == tklgen::TKRightParenthesisCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //RangeOpt => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionSingle(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKLeftCurlyBracketCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //SyntaxExpressionSingle => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tklgen::TKKeywordEmpty)
        {
            //SyntaxExpressionSingle => KeywordEmpty 
            ctx.Match(tklgen::TKKeywordEmpty);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionMoreSingle(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKVerticalLineCharacter)
        {
            //SyntaxExpressionMoreSingle => VerticalLineCharacter SyntaxExpressionSingle SyntaxExpressionMoreSingle 
            ctx.Match(tklgen::TKVerticalLineCharacter);
            Parse_SyntaxExpressionSingle(ctx);
            Parse_SyntaxExpressionMoreSingle(ctx);
        }
        else if (ctx.Token() == tklgen::TKSemicolonCharacter)
        {
            //SyntaxExpressionMoreSingle => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionItem(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKIdentifier)
        {
            //SyntaxExpressionItem => Identifier 
            ctx.Match(tklgen::TKIdentifier);
        }
        else if (ctx.Token() == tklgen::TKLiteralChar)
        {
            //SyntaxExpressionItem => LiteralChar 
            ctx.Match(tklgen::TKLiteralChar);
        }
        else if (ctx.Token() == tklgen::TKStringLiteral)
        {
            //SyntaxExpressionItem => StringLiteral 
            ctx.Match(tklgen::TKStringLiteral);
        }
        else if (ctx.Token() == tklgen::TKLeftCurlyBracketCharacter)
        {
            //SyntaxExpressionItem => SyntaxExpressionAction 
            Parse_SyntaxExpressionAction(ctx);
        }
        else
        {
            assert(false);
        }
    }

    void Parse_SyntaxExpressionSingleFollow(Context& ctx)
    {
        if (ctx.Token() == tklgen::TKLiteralChar ||
            ctx.Token() == tklgen::TKIdentifier ||
            ctx.Token() == tklgen::TKLeftCurlyBracketCharacter ||
            ctx.Token() == tklgen::TKStringLiteral)
        {
            //SyntaxExpressionSingleFollow => SyntaxExpressionItem SyntaxExpressionSingleFollow 
            Parse_SyntaxExpressionItem(ctx);
            Parse_SyntaxExpressionSingleFollow(ctx);
        }
        else if (ctx.Token() == tklgen::TKSemicolonCharacter ||
            ctx.Token() == tklgen::TKVerticalLineCharacter)
        {
            //SyntaxExpressionSingleFollow => Epsilon 
        }
        else
        {
            assert(false);
        }
    }

} //namespace tklgen
