/*
 * Generated by TKLGEN - VersionNov  9 2015
 * Copyright (C) 2013, Thiago Adams (thiago.adams@gmail.com)
 * www.thradams.com
 *
 */

#include "stdafx.h"
#include <assert.h>

#include "PlaygroundModuleLex.h"
#include "PlaygroundModuleParser.h"


#include "sstream.h"
#include "errors.h"


//
const wchar_t* PlaygroundLang_Actions_Text(enum PlaygroundLang_Actions e)
{
    switch(e)
    {
        case  PrintNewLine: return L"PrintNewLine";
        case  PrintPlus: return L"PrintPlus";
        case  PrintMinus: return L"PrintMinus";
        case  PrintMulti: return L"PrintMulti";
        case  PrintDiv: return L"PrintDiv";
        case  PrintPower: return L"PrintPower";
        case  PrintLexeme: return L"PrintLexeme";
        case  PrintNeg: return L"PrintNeg";
    }
    return L"";
};


#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <stdbool.h>
#include "errors.h"

inline bool IsError(ResultCode e)
{
    if ((e != ResultCodeSuccess &&
    e != ResultCodeEmpty))
    {
        return true;
    }

    return false;
}

#define IFER(x) if (IsError(x)) return ResultCodeError;

static ResultCode resize_lexeme(PlaygroundLang_Context* p, size_t sz)
{
    wchar_t *newlexeme = (wchar_t*)malloc(sizeof(wchar_t) * sz);
    if (newlexeme == NULL)
    {
        return ResultCodeOutOfMem;
    }

    if (p->lexeme)
    {
        free(p->lexeme);
        p->lexemeSize = 0;
    }

    p->lexeme = newlexeme;
    p->lexemeSize = sz;
    p->lexeme[0] = L'\0';

    return ResultCodeSuccess;
}

static ResultCode PlaygroundLang_Context_Init(PlaygroundLang_Context* p, int initialLexemeSize)
{
    p->lexemeSize = 0;
    p->lexeme = 0;

    ResultCode r = resize_lexeme(p, initialLexemeSize);
    if (r == ResultCodeSuccess)
    {
        p->lexeme[0] = L'\0';
        p->stream = 0;
        p->token = (enum PlaygroundLang_Tokens) 0;
    }
    
    return r;
}

static void PlaygroundLang_Context_destroy(PlaygroundLang_Context* p)
{
    p->lexemeSize = 0;
    free(p->lexeme);
}

static ResultCode ReadNextToken(PlaygroundLang_Context* context)
{
    return PlaygroundLang_NextToken(context->stream,
                          &context->lexeme,
                          &context->lexemeSize,
                          &context->token);
}

static ResultCode Match(PlaygroundLang_Context* context, enum PlaygroundLang_Tokens tk)
{
    if (tk != context->token)
    {
        return ResultCodeUnexpectedToken;
    }

    ResultCode r = ReadNextToken(context);

    if (r != ResultCodeSuccess &&
    r != ResultCodeEof)
    {
        return r;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_Main(PlaygroundLang_Context* ctx);
ResultCode PlaygroundLang_Parse(struct sstream* ss,
                      PlaygroundLang_OnAction action, void* root)
{
    PlaygroundLang_Context ctx;
    ResultCode r = PlaygroundLang_Context_Init(&ctx, 200);
    if (r == ResultCodeSuccess)
    {
        ctx.stream = ss;
        ctx.on_action = action;
        r = ReadNextToken(&ctx);

        if (r == ResultCodeSuccess)
        {
            r = Parse_Main(&ctx);
        }
    }

    PlaygroundLang_Context_destroy(&ctx);    
    return r;
}

ResultCode PlaygroundLang_Parse_Str(const wchar_t* text,
                              PlaygroundLang_OnAction action,
                              void* root,
                              int* line,
                              int* col)
{
    struct sstream ss;
    sstream_init(&ss, text);
    ResultCode r = PlaygroundLang_Parse(&ss, action, root);
    *line = ss.line;
    *col = ss.col;
    return r;
}

/*forward declarations*/ 
ResultCode Parse_Expressions( PlaygroundLang_Context* ctx);
ResultCode Parse_Main( PlaygroundLang_Context* ctx);
ResultCode Parse_Expression( PlaygroundLang_Context* ctx);
ResultCode Parse_E( PlaygroundLang_Context* ctx);
ResultCode Parse_E2( PlaygroundLang_Context* ctx);
ResultCode Parse_T( PlaygroundLang_Context* ctx);
ResultCode Parse_T2( PlaygroundLang_Context* ctx);
ResultCode Parse_F( PlaygroundLang_Context* ctx);
ResultCode Parse_P( PlaygroundLang_Context* ctx);
ResultCode Parse_FOpt( PlaygroundLang_Context* ctx);


ResultCode Parse_Expressions( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKMinus ||
        token == TKInteger ||
        token == TKOpen ||
        token == TKIdentifier)
    {
        /*Expressions => Expression Expressions */
        IFER(Parse_Expression(ctx));
        IFER(Parse_Expressions(ctx));
    }
    else if (token == TKEndMark)
    {
        /*Expressions => Epsilon */
        return ResultCodeEmpty; /*opt*/
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_Main( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKMinus ||
        token == TKEndMark ||
        token == TKInteger ||
        token == TKOpen ||
        token == TKIdentifier)
    {
        /*Main => Expressions */
        IFER(Parse_Expressions(ctx));
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_Expression( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKMinus ||
        token == TKInteger ||
        token == TKOpen ||
        token == TKIdentifier)
    {
        /*Expression => E End */
        IFER(Parse_E(ctx));
        IFER(Match(ctx, TKEnd));
        IFER(ctx->on_action(PrintNewLine, ctx));
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_E( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKMinus ||
        token == TKInteger ||
        token == TKOpen ||
        token == TKIdentifier)
    {
        /*E => T E2 */
        IFER(Parse_T(ctx));
        IFER(Parse_E2(ctx));
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_E2( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKPlus)
    {
        /*E2 => Plus T E2 */
        IFER(Match(ctx, TKPlus));
        IFER(Parse_T(ctx));
        IFER(ctx->on_action(PrintPlus, ctx));
        IFER(Parse_E2(ctx));
    }
    else if (token == TKMinus)
    {
        /*E2 => Minus T E2 */
        IFER(Match(ctx, TKMinus));
        IFER(Parse_T(ctx));
        IFER(ctx->on_action(PrintMinus, ctx));
        IFER(Parse_E2(ctx));
    }
    else if (token == TKEnd ||
        token == TKClose)
    {
        /*E2 => Epsilon */
        return ResultCodeEmpty; /*opt*/
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_T( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKMinus ||
        token == TKInteger ||
        token == TKOpen ||
        token == TKIdentifier)
    {
        /*T => F T2 */
        IFER(Parse_F(ctx));
        IFER(Parse_T2(ctx));
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_T2( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKMulti)
    {
        /*T2 => Multi F T2 */
        IFER(Match(ctx, TKMulti));
        IFER(Parse_F(ctx));
        IFER(ctx->on_action(PrintMulti, ctx));
        IFER(Parse_T2(ctx));
    }
    else if (token == TKDiv)
    {
        /*T2 => Div F T2 */
        IFER(Match(ctx, TKDiv));
        IFER(Parse_F(ctx));
        IFER(ctx->on_action(PrintDiv, ctx));
        IFER(Parse_T2(ctx));
    }
    else if (token == TKDiv ||
        token == TKPlus ||
        token == TKMulti ||
        token == TKMinus ||
        token == TKPower ||
        token == TKEnd ||
        token == TKClose)
    {
        /*T2 => Epsilon */
        return ResultCodeEmpty; /*opt*/
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_F( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKMinus ||
        token == TKInteger ||
        token == TKOpen ||
        token == TKIdentifier)
    {
        /*F => P FOpt */
        IFER(Parse_P(ctx));
        IFER(Parse_FOpt(ctx));
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_P( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKInteger)
    {
        /*P => Integer */
        IFER(ctx->on_action(PrintLexeme, ctx));
        IFER(Match(ctx, TKInteger));
    }
    else if (token == TKIdentifier)
    {
        /*P => Identifier */
        IFER(ctx->on_action(PrintLexeme, ctx));
        IFER(Match(ctx, TKIdentifier));
    }
    else if (token == TKOpen)
    {
        /*P => Open E Close */
        IFER(Match(ctx, TKOpen));
        IFER(Parse_E(ctx));
        IFER(Match(ctx, TKClose));
    }
    else if (token == TKMinus)
    {
        /*P => Minus T */
        IFER(Match(ctx, TKMinus));
        IFER(Parse_T(ctx));
        IFER(ctx->on_action(PrintNeg, ctx));
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

ResultCode Parse_FOpt( PlaygroundLang_Context* ctx)
{
    enum PlaygroundLang_Tokens token = ctx->token; 

    if (token == TKPower)
    {
        /*FOpt => Power F */
        IFER(Match(ctx, TKPower));
        IFER(Parse_F(ctx));
        IFER(ctx->on_action(PrintPower, ctx));
    }
    else if (token == TKDiv ||
        token == TKPlus ||
        token == TKMulti ||
        token == TKMinus ||
        token == TKPower ||
        token == TKEnd ||
        token == TKClose)
    {
        /*FOpt => Epsilon */
        return ResultCodeEmpty; /*opt*/
    }
    else
    {
        ctx->on_action(OnError, ctx);
        return ResultCodeError;
    }

    return ResultCodeSuccess;
}

